// -*- javascript -*-
// 	Processing.js Example

var ProPoint = function(x,y) {
  this.x = x;
  this.y = y;
};

ProPoint.prototype = {
  distance: function( pt ) {
    return (this.minus(pt)).v_length()
  },

  v_length: function() {
    return Math.sqrt((this.x * this.x) + (this.y * this.y));
  },
  
  equals: function( pt ) {
    return (this.x == pt.x) && (this.y == pt.y);
  },
  minus: function( pt ) {
    return new ProPoint( this.x - pt.x, this.y - pt.y );
  },
  plus: function( pt ) {
    return new ProPoint( this.x + pt.x, this.y + pt.y );
  },
  multiple: function( factor ) {
    return new ProPoint( this.x * factor, this.y * factor );
  },

  // return a point that is located between this point and the given point
  // defined by ratio (value between 0 and 1 inclusive). If ratio is greater
  // than 1, then a point beyond the line joining the points is returned
  point_on_segment: function( pt, ratio ) {
    if ( this.equals(pt) ) { return new ProPoint( pt.x, pt.y ); }
    return this.minus(this.minus(pt).multiple(ratio));
  },

  slope: function( pt ) {
    if (this.equals(pt) ) {
      throw "SamePointsError";
    } else if ( this.x == pt.x) {
      throw "PointsVerticalError";
    }
    return ( (this.y - pt.y) / (this.x - pt.x) );
  },

  clone: function() {
    return new ProPoint(this.x, this.y);
  },

  to_s: function() {
    return "Point: " + this.x + ", " + this.y;
  }
};

var ProCircle = function(center, radius) {
  this.cpt = center;
  this.radius = radius;
};

ProCircle.prototype = {
  center_pt: function() {
    return this.cpt.clone();
  },

  draw: function() {
    ellipse( this.cpt.x, this.cpt.y, this.radius*2, this.radius*2);
  },

  points: function( point_count ) {
    pts = [];
    delta = (2 * Math.PI) / point_count;
    for (var idx = 1; idx <= point_count; idx++) {
      pts.push( new ProPoint( this.radius * Math.cos( delta * idx ) + this.cpt.x,
                              this.radius * Math.sin( delta * idx ) + this.cpt.y ))
    }

    return pts;
  },

  distance: function( other_circle ) {
    return this.cpt.distance(other_circle.cpt);
  },

  equals: function( other_circle ) {
    return (other_circle.cpt.equals(this.cpt) && this.radius == other_circle.radius);
  },

  intersection: function( other_circle ) {
    var distance = this.distance(other_circle);
    var r0 = this.radius;
    var r1 = other_circle.radius;

    // don't intersect - too far apart
    if ( distance > (r0 + r1)) { return []; }
    // infinite number of solutions ... same circle
    if ( this.equals(other_circle) ) { return []; }
    // one circle is contained in the other - no intersection points
    if ( distance < Math.abs(r0 - r1)) { return []; }
    
    var a = ((r0*r0) - (r1*r1) + (distance * distance)) / (2 * distance);
    var h = Math.sqrt((r0*r0) - (a*a));

    var tpt = other_circle.cpt.minus(this.cpt);
    var dx = tpt.x;
    var dy = tpt.y;

    var twoPt = new ProPoint(this.cpt.x + (dx*a/distance), this.cpt.y + (dy*a/distance));
    var rPt = new ProPoint(-dy * (h/distance), dx * (h/distance));
    
    return [twoPt.plus(rPt), twoPt.minus(rPt)];
  }
};

void setup() {
  size(600, 600);
}

void draw() {
  background(#001100);
  stroke(255,156,255);
  noFill();
  var base_radius = 100;
  var num_of_points = 6;

  var center_circle = new ProCircle(new ProPoint(300,300), base_radius);

  var pts = center_circle.points(num_of_points);
  for ( var idx = 0; idx < num_of_points; idx++ ) {
    var center_pt = center_circle.cpt.point_on_segment(pts[idx], 1.5);
    var new_circle = new ProCircle(center_pt, base_radius);
    new_circle.draw();
    var new_pts = new_circle.intersection( center_circle );
    (new ProCircle(new_pts[0], 10)).draw();
    (new ProCircle(new_pts[1], 10)).draw();
  }

  center_circle.draw();

  exit(); // remove once stable
}

